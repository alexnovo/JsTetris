<!doctype html>
<html>
<head>
    <title>Tetris</title>
    <meta charset='utf-8' />
    <script src="./js/bufferLoader.js"></script>
    <script src="./js/helper.js"></script>
        <style>
        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;
        }
        canvas {
            background: #CCC;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body onload="loadPage()" onkeydown="keyDown()" onmousedown="mouseDown()" onresize="resizeCanvas()">
    <canvas id='myCanvas' height='1080' width='1920'>Not support</canvas>
    <script>
        var sounds = [];

        var N = 20; // количество строк
        var M = 10; // количество столбцов
        var cellWidth, cellHeight;
        var gameBoard;
        var gameBoardPosX, gameBoardPosY;
        var gameState;
        var currentFigure, nextFigure;

        var myTimer = 0; // счетчик миллисекунд
        var lastMove = myTimer; // для ограничения перемещений фигуры
        var lastDownMove = myTimer; // для ограничений падения
        var speed = 1.0; // скорость спуска фигуры (ячеек / в секунду)
        var MAX_SPEED = 30;
        var showFps = true;
        var score = 0;

        var MOVE = { LEFT: 1, RIGHT: 2, DOWN: 3, MOVE: 4 };
        var nextMove = 0;
        var myCanvas = document.getElementById("myCanvas");
        var drawContext = myCanvas.getContext('2d');

        var MAX_COLOR_CODE = 6;
        var COLOR_CODE_GRAY = 7; // серый для фона
        var COLOR_GRAY = "#808080";
        var COLOR_BLUE = "#0000FF";
        var COLOR_BLACK = "#000000";
        function getColor(colorCode) {
            switch (colorCode) {
                case 1:
                    return "#FF0000";
                case 2:
                    return "#00FF00";
                case 3:
                    return COLOR_BLUE;
                case 4:
                    return "#FFFF00";
                case 5:
                    return "#FF00FF";
                case 6:
                    return "#00FFFF";
                case COLOR_CODE_GRAY:
                    return COLOR_GRAY;
                default:
                    return "#D0D0D0";
            }
        }

        var FIGURE_CODE = { CUBE: 0, LINE: 1, VISOR1: 2, VISOR2: 3, STAIR1: 4, STAIR2: 5, LEDGE: 6 };
        var MAX_FIGURE_CODE = 7
        function Figure(figureCode, colorCode) {
            this.code = figureCode;
            this.colorCode = colorCode;
            // координаты появления
            this.j = Math.floor((M - 3) / 2);
            this.i = 0; // todo -2
            var c = colorCode;
            switch (figureCode) {
                case FIGURE_CODE.LINE:
                    this.data = [
                        [0, c, 0],
                        [0, c, 0],
                        [0, c, 0],
                    ];
                    break;
                case FIGURE_CODE.VISOR1:
                    this.data = [
                        [0, c, c],
                        [0, c, 0],
                        [0, c, 0],
                    ];
                    break;
                case FIGURE_CODE.VISOR2:
                    this.data = [
                        [c, c, 0],
                        [0, c, 0],
                        [0, c, 0],
                    ];
                    break;
                case FIGURE_CODE.STAIR1:
                    this.data = [
                        [0, 0, c],
                        [0, c, c],
                        [0, c, 0],
                    ];
                    break;
                case FIGURE_CODE.STAIR2:
                    this.data = [
                        [c, 0, 0],
                        [c, c, 0],
                        [0, c, 0],
                    ];
                    break;
                case FIGURE_CODE.LEDGE:
                    this.data = [
                        [0, c, 0],
                        [0, c, c],
                        [0, c, 0],
                    ];
                    break;
                    //case FIGURE_CODE.CUBE:
                default:
                    this.data = [
                        [0, 0, 0],
                        [0, c, c],
                        [0, c, c],
                    ];
                    break;
            }
        }
        function copyFigure(figureDst, figureSrc) {
            figureDst.code = figureSrc.code;
            figureDst.j = figureSrc.j;
            figureDst.i = figureSrc.i;
            var i, j;
            for (i = 0; i < 3; ++i)
                for (j = 0; j < 3; ++j)
                    figureDst.data[i][j] = figureSrc.data[i][j];
        }
        function resizeCanvas() {
            myCanvas.width = window.innerWidth;
            myCanvas.height = window.innerHeight;
            cellWidth = cellHeight = Math.floor(Math.min(myCanvas.width / M, (myCanvas.height) / (N+2)));
            drawContext.font = cellWidth.toString() + 'px Arial';
            gameBoardPosX = (myCanvas.width - cellWidth * M) / 2;
            gameBoardPosY = cellHeight*2;
        }
        var GAME_STATE = { MENU: 0, PLAY: 1, GAME_OVER: 2 };
        function loadPage() {
            resizeCanvas();

            initAudio();
            initGame();

            setInterval(doStep, 1000 / (2 * MAX_SPEED));
            setInterval(draw, 1000 / 30); // 30 fps
        }
        function initGame() {
            var i, j;
            gameBoard = new Array(N);
            for (i = 0; i < N; ++i) {
                gameBoard[i] = new Array(M);
                for (j = 0; j < M; ++j)
                    gameBoard[i][j] = 0;
            }
            // добавим "рамку" чтоб не проверять граничные условия
            for (i = 0; i < N; ++i)
                gameBoard[i][0] = gameBoard[i][M - 1] = COLOR_CODE_GRAY;
            for (j = 0; j < M; ++j)
                gameBoard[N - 1][j] = COLOR_CODE_GRAY;

            currentFigure = new Figure(
                Math.round(Math.random() * MAX_FIGURE_CODE),
                Math.round(Math.random() * (MAX_COLOR_CODE - 1) + 1));
            nextFigure = new Figure(
                Math.round(Math.random() * MAX_FIGURE_CODE),
                Math.round(Math.random() * (MAX_COLOR_CODE - 1) + 1));
            myTimer = new Date().getTime();
            lastMove = myTimer;
            lastDownMove = myTimer;
            speed = 1.0;
            score = 0;
            nextMove = 0;

            gameState = GAME_STATE.MENU;
        }

        function doStep() {
            if (gameState != GAME_STATE.PLAY)
                return;
            var isTryDown = false;   // была попытка подвинуть вниз
            var isMovedDown = false; // был сдвиг вниз
            myTimer = new Date().getTime();
            if (myTimer - lastMove >= 1000 / MAX_SPEED && nextMove != 0) // команды пользователя
            {
                switch (nextMove) {
                    case MOVE.LEFT:
                        tryMove(currentFigure, 0, -1);
                        break;
                    case MOVE.RIGHT:
                        tryMove(currentFigure, 0, 1);
                        break;
                    case MOVE.DOWN:
                        if (tryMove(currentFigure, 1, 0)) {
                            isMovedDown = true;
                            lastDownMove = myTimer;
                        }
                        isTryDown = true;
                        break;
                    case MOVE.ROTATE:
                        tryTurn(currentFigure);
                        break;
                }
                lastMove = myTimer;
                nextMove = 0;
            }
            if (myTimer - lastDownMove >= 1000 / speed) // падение
            {
                if (tryMove(currentFigure, 1, 0)) {
                    isMovedDown = true;
                    lastDownMove = myTimer;
                }
                isTryDown = true;
            }
            if ( isTryDown && !isMovedDown){
                playSound('drop');
                // "положить" фигуру на поле
                var i, j;
                for (i = 0; i < 3; ++i)
                    for (j = 0; j < 3; ++j) {
                        if (currentFigure.data[i][j] != 0)
                            gameBoard[currentFigure.i + i][currentFigure.j + j] = currentFigure.data[i][j];
                    }
                currentFigure = nextFigure;
                nextFigure = new Figure(
                    Math.round(Math.random() * MAX_FIGURE_CODE),
                    Math.round(Math.random() * (MAX_COLOR_CODE - 1) + 1));
                if (tryMove(currentFigure, 1, 0) == false) {
                    currentFigure.i--;
                    gameState = GAME_STATE.GAME_OVER;
                }
                doClear();
            }
        }
        function doClear() {
            var cnt = 0;
            for (i = N - 2; i > 1;) {
                var isFullLine = true;
                var isEmptyLine = true;
                for (j = 1; j < M - 1; ++j) {
                    if (gameBoard[i][j] == 0)
                        isFullLine = false;
                    else
                        isEmptyLine = false;
                }
                if (isEmptyLine)
                    break;
                if (isFullLine) {
                    var k;
                    for (k = i; k > 0; --k)
                        gameBoard[k] = gameBoard[k - 1].slice();
                    for (j = 1; j < M - 1; ++j)
                        gameBoard[0][j] = 0;
                    ++cnt;
                } else {
                    --i;
                }
            }
            if (cnt > 0)
                playSound('clear');
            if (cnt>2)
                score += 2000;
            if (cnt>1)
                score += 500;
            if (cnt==1)
                score += 100;
        }

        function checkOverlap(figure) {
            var i, j;
            for (i = 0; i < 3; ++i)
                for (j = 0; j < 3; ++j) {
                    if (figure.data[i][j] != 0 && gameBoard[figure.i + i][figure.j + j] != 0)
                        return true;
                }
            return false;
        }

        function tryMove(figure, di, dj) {
            var movedFigure = new Figure();
            copyFigure(movedFigure, figure);
            movedFigure.i += di;
            movedFigure.j += dj;
            if (checkOverlap(movedFigure) == false) {
                //playSound('move');
                figure.i = movedFigure.i;
                figure.j = movedFigure.j;
                return true;
            }
            return false;
        }

        function tryTurn(figure) {
            if (figure.code == FIGURE_CODE.CUBE)
                return false;
            var turnedFigure = new Figure();
            copyFigure(turnedFigure, figure);
            var i, j;
            for (i = 0; i < 3; ++i)
                for (j = 0; j < 3; ++j)
                    turnedFigure.data[i][j] = figure.data[2 - j][i];
            if (checkOverlap(turnedFigure) == false) {
                for (i = 0; i < 3; ++i)
                    for (j = 0; j < 3; ++j)
                        figure.data[i][j] = turnedFigure.data[i][j];
                return true;
            }
            return false;
        }

        function drawBoard() {
            drawContext.fillStyle = COLOR_GRAY;
            drawContext.fillRect(gameBoardPosX, 0, cellWidth * M - 1, cellHeight * 2);

            var i, j;
            for (i = 0; i < N; ++i) {
                for (j = 0; j < M; ++j) {
                    drawContext.fillStyle = getColor(gameBoard[i][j]);
                    if (gameBoard[i][j] != 0)
                        drawContext.fillRect(
                            gameBoardPosX + j * cellHeight,
                            gameBoardPosY + i * cellWidth, cellWidth - 1, cellHeight - 1);
                    else
                        drawContext.fillRect(
                            gameBoardPosX + j * cellHeight,
                            gameBoardPosY + i * cellWidth, cellWidth, cellHeight);
                }
            }
        }

        var lastLoop = new Date().getTime();
        function drawInfo() {
            var info = "";
            if (showFps) {
                var thisLoop = new Date().getTime();
                var fps = 1000 / (thisLoop - lastLoop);
                lastLoop = thisLoop;
                info = fps.toFixed(1) + ' fps ';
            }
            info += ' Score: ' + score;
            drawContext.fillStyle = COLOR_BLACK;
            drawContext.fillText(info, gameBoardPosX, cellHeight);
        }

        function drawFigure(figure) {
            drawContext.fillStyle = getColor(figure.colorCode);
            var i, j;
            for (i = 0; i < 3; ++i) {
                for (j = 0; j < 3; ++j) {
                    if (figure.data[i][j] != 0)
                        drawContext.fillRect(
                            gameBoardPosX + (figure.j + j) * cellHeight,
                            gameBoardPosY + (figure.i + i) * cellWidth, cellWidth - 1, cellHeight - 1);
                }
            }
        }

        function draw() {
            switch (gameState) {
                case GAME_STATE.MENU:
                    {
                        drawBoard();
                        drawContext.fillStyle = COLOR_BLACK;
                        drawContext.textAlign = "center";
                        var str = "Press to start.";
                        drawContext.fillText(str, myCanvas.width / 2, myCanvas.height / 2);
                    } break;
                case GAME_STATE.PLAY:
                    {
                        drawContext.textAlign = "left";
                        drawBoard();
                        drawInfo();
                        drawFigure(currentFigure);
                    } break;
                case GAME_STATE.GAME_OVER:
                    {
                        drawContext.fillStyle = COLOR_BLACK;
                        drawContext.textAlign = "center";
                        var str = "You result: " + score;
                        drawContext.fillText(str, myCanvas.width / 2, myCanvas.height / 2);
                    } break;
            }
        }
        var KEY_UP = 38, KEY_DOWN = 40, KEY_LEFT = 37, KEY_RIGHT = 39, KEY_ENTER = 13;
        function keyDown() {
            switch (gameState) {
                case GAME_STATE.MENU:
                    {
                        gameState = GAME_STATE.PLAY;
                    } break;
                case GAME_STATE.PLAY:
                    {
                        switch (event.keyCode) {
                            case KEY_UP:
                                nextMove = MOVE.ROTATE;
                                break;
                            case KEY_DOWN:
                                nextMove = MOVE.DOWN;
                                break;
                            case KEY_LEFT:
                                nextMove = MOVE.LEFT;
                                break;
                            case KEY_RIGHT:
                                nextMove = MOVE.RIGHT;
                                break;
                        }
                    } break;
                case GAME_STATE.GAME_OVER:
                    {
                        initGame();
                        gameState = GAME_STATE.MENU;
                    } break;
            }
        }
        var MB_LEFT = 1;
        function mouseDown() {
            //if (event.button == MB_LEFT)
            nextMove = MOVE.ROTATE;
        }

        function initAudio() {
            if (getBrowserName()=="safari") // for Lg WebOS
            {
                isWebKit = true;
                window.context;
                window.bufferLoader;
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                context = new AudioContext();
                bufferLoader = new BufferLoader(
                    context,
                    [
                        './sounds/move.wav',
                        './sounds/drop.wav',
                        './sounds/clear.wav',
                    ],
                    function () { }
                );
                bufferLoader.load();
            }
        }
        var isWebKit = false;
        function playSound(id) {
            if (isWebKit){
                playSoundForWebKit(id);
                return;
            }
            var element = document.getElementById(id);
            if (sounds[id] == undefined) {
                sounds[id] = new Audio("./sounds/" + id + ".wav");
                sounds[id].load();
            }
            if (sounds[id].played.length == 0 || sounds[id].ended)
                sounds[id].play();
        }
        
        function playSoundForWebKit(id) {
            var source = context.createBufferSource(); // может не стоит каждый раз вызывать?
            var idx = 0;
            switch (id) { // fixme сделать список звуков
                case 'move':  idx = 0; break;
                case 'drop':  idx = 1; break;
                case 'clear': idx = 2; break;
            }
            source.buffer = window.bufferLoader.bufferList[idx];
            source.connect(context.destination);
            source.start(0);
        }

    </script>
</body>
</html>
