<!doctype html>
<html>
<head>
    <title>Tetris</title>
    <meta charset='utf-8' />
    <script src="./scripts/scripts.js"></script>
        <style>
        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;
        }
        canvas {
            background: #CCC;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body onload="initGame()" onkeydown="keyDown()" onmousedown="mouseDown()" onresize="resizeCanvas()">
    <canvas id='myCanvas' height='1080' width='1920'>Not support</canvas>
    <script>
        var dropSound = new Audio("./sounds/drop.wav");
        var clearSound = new Audio("./sounds/clear.wav");
        var moveSound = new Audio("./sounds/move.wav");

        var N = 20; // количество строк
        var M = 10; // количество столбцов
        var cellWidth, cellHeight;
        var gameBoard;
        var gameBoardPosX, gameBoardPosY;
        var gameState;
        var currentFigure, nextFigure;

        var myTimer = 0; // счетчик миллисекунд
        var lastMove = myTimer; // для ограничения перемещений фигуры
        var lastDownMove = myTimer; // для ограничений падения
        var speed = 1.0; // скорость спуска фигуры (ячеек / в секунду)
        var MAX_SPEED = 30;
        var showFps = true;
        var score = 0;

        var MOVE_LEFT = 1, MOVE_RIGHT = 2, MOVE_DOWN = 3, MOVE_ROTATE = 4;
        var nextMove = 0;
        var myCanvas = document.getElementById("myCanvas");
        var drawContext = myCanvas.getContext('2d');

        var MAX_COLOR_CODE = 6;
        var COLOR_CODE_GRAY = 7; var COLOR_GRAY = "#808080";
        var COLOR_BLUE = "#0000FF";
        var COLOR_BLACK = "#000000";
        function getColor(colorCode) {
            switch (colorCode) {
                case 1:
                    return "#FF0000";
                case 2:
                    return "#00FF00";
                case 3:
                    return COLOR_BLUE;
                case 4:
                    return "#FFFF00";
                case 5:
                    return "#FF00FF";
                case 6:
                    return "#00FFFF";
                case COLOR_CODE_GRAY:
                    return COLOR_GRAY;
                default:
                    return "#D0D0D0";
            }
        }

        var FIGURE_CODE_CUBE = 0;
        var FIGURE_CODE_LINE = 1;
        var FIGURE_CODE_VISOR1 = 2;
        var FIGURE_CODE_VISOR2 = 3;
        var FIGURE_CODE_STAIR1 = 4;
        var FIGURE_CODE_STAIR2 = 5;
        var FIGURE_CODE_LEDGE = 6;
        var MAX_FIGURE_CODE = 6;
        function Figure(figureCode, colorCode) {
            this.code = figureCode;
            this.colorCode = colorCode;
            // координаты появления
            this.j = Math.floor((M - 3) / 2);
            this.i = 0; // todo -2
            var c = colorCode;
            switch (figureCode) {
                case FIGURE_CODE_LINE:
                    this.data = [
                        [0, c, 0],
                        [0, c, 0],
                        [0, c, 0],
                    ];
                    break;
                case FIGURE_CODE_VISOR1:
                    this.data = [
                        [0, c, c],
                        [0, c, 0],
                        [0, c, 0],
                    ];
                    break;
                case FIGURE_CODE_VISOR2:
                    this.data = [
                        [c, c, 0],
                        [0, c, 0],
                        [0, c, 0],
                    ];
                    break;
                case FIGURE_CODE_STAIR1:
                    this.data = [
                        [0, 0, c],
                        [0, c, c],
                        [0, c, 0],
                    ];
                    break;
                case FIGURE_CODE_STAIR2:
                    this.data = [
                        [c, 0, 0],
                        [c, c, 0],
                        [0, c, 0],
                    ];
                    break;
                case FIGURE_CODE_LEDGE:
                    this.data = [
                        [0, c, 0],
                        [0, c, c],
                        [0, c, 0],
                    ];
                    break;
                    //case FIGURE_CODE_CUBE:
                default:
                    this.data = [
                        [0, 0, 0],
                        [0, c, c],
                        [0, c, c],
                    ];
                    break;
            }
        }
        function copyFigure(figureDst, figureSrc) {
            figureDst.code = figureSrc.code;
            figureDst.j = figureSrc.j;
            figureDst.i = figureSrc.i;
            var i, j;
            for (i = 0; i < 3; ++i)
                for (j = 0; j < 3; ++j)
                    figureDst.data[i][j] = figureSrc.data[i][j];
        }
        function resizeCanvas() {
            myCanvas.width = window.innerWidth;
            myCanvas.height = window.innerHeight;
            cellWidth = cellHeight = Math.floor(Math.min(myCanvas.width / M, (myCanvas.height) / (N+2)));
            drawContext.font = cellWidth.toString() + 'px Arial';
            gameBoardPosX = (myCanvas.width - cellWidth * M) / 2;
            gameBoardPosY = cellHeight*2;
        }
        var GAME_STATE_MENU = 0, GAME_STATE_PLAY = 1, GAME_STATE_END = 2;
        function initGame() {
            myCanvas = document.getElementById("myCanvas");
            drawContext = myCanvas.getContext('2d');
            resizeCanvas();   
            var i, j;
            gameBoard = new Array(N);
            for (i = 0; i < N; ++i) {
                gameBoard[i] = new Array(M);
                for (j = 0; j < M; ++j)
                    gameBoard[i][j] = 0;
            }
            // добавим "рамку" чтоб не проверять граничные условия
            for (i = 0; i < N; ++i)
                gameBoard[i][0] = gameBoard[i][M - 1] = COLOR_CODE_GRAY;
            for (j = 0; j < M; ++j)
                gameBoard[N - 1][j] = COLOR_CODE_GRAY;

            currentFigure = new Figure(
                Math.round(Math.random() * MAX_FIGURE_CODE),
                Math.round(Math.random() * (MAX_COLOR_CODE - 1) + 1));
            nextFigure = new Figure(
                Math.round(Math.random() * MAX_FIGURE_CODE),
                Math.round(Math.random() * (MAX_COLOR_CODE - 1) + 1));
            myTimer = 0;
            lastMove = myTimer;
            lastDownMove = myTimer;
            speed = 1.0;
            score = 0;
            nextMove = 0;


            gameState = GAME_STATE_MENU;

            setInterval(doStep, 1000 / (2 * MAX_SPEED));
            setInterval(draw, 1000 / 30); // 30 fps
            setInterval(incTimer, 10);
        }
        function incTimer() {
            myTimer+=10;
        }

        function doStep() {
            if (gameState != GAME_STATE_PLAY)
                return;
            var isTryDown = false;   // была попытка подвинуть вниз
            var isMovedDown = false; // был сдвиг вниз
            if (myTimer - lastMove >= 1000 / MAX_SPEED && nextMove != 0) // команды пользователя
            {
                switch (nextMove) {
                    case MOVE_LEFT:
                        tryMove(currentFigure, 0, -1);
                        break;
                    case MOVE_RIGHT:
                        tryMove(currentFigure, 0, 1);
                        break;
                    case MOVE_DOWN:
                        if (tryMove(currentFigure, 1, 0)) {
                            isMovedDown = true;
                            lastDownMove = myTimer;
                        }
                        isTryDown = true;
                        break;
                    case MOVE_ROTATE:
                        tryTurn(currentFigure);
                        break;
                }
                lastMove = myTimer;
                nextMove = 0;
            }
            if (myTimer - lastDownMove >= 1000 / speed) // падение
            {
                if (tryMove(currentFigure, 1, 0)) {
                    isMovedDown = true;
                    lastDownMove = myTimer;
                }
                isTryDown = true;
            }
            if ( isTryDown && !isMovedDown){
                dropSound.play();
                // "положить" фигуру на поле
                var i, j;
                for (i = 0; i < 3; ++i)
                    for (j = 0; j < 3; ++j) {
                        if (currentFigure.data[i][j] != 0)
                            gameBoard[currentFigure.i + i][currentFigure.j + j] = currentFigure.data[i][j];
                    }
                currentFigure = nextFigure;
                nextFigure = new Figure(
                    Math.round(Math.random() * MAX_FIGURE_CODE),
                    Math.round(Math.random() * (MAX_COLOR_CODE - 1) + 1));
                if (tryMove(currentFigure, 1, 0) == false) {
                    currentFigure.i--;
                    gameState = GAME_STATE_END;
                }
                doClear();
            }
        }
        function doClear() {
            var cnt = 0;
            for (i = N - 2; i > 1;) {
                var isFullLine = true;
                var isEmptyLine = true;
                for (j = 1; j < M - 1; ++j) {
                    if (gameBoard[i][j] == 0)
                        isFullLine = false;
                    else
                        isEmptyLine = false;
                }
                if (isEmptyLine)
                    break;
                if (isFullLine) {
                    var k;
                    for (k = i; k > 0; --k)
                        gameBoard[k] = gameBoard[k - 1].slice();
                    for (j = 1; j < M - 1; ++j)
                        gameBoard[0][j] = 0;
                    ++cnt;
                } else {
                    --i;
                }
            }
            if (cnt > 0)
                clearSound.play();
            if (cnt>2)
                score += 2000;
            if (cnt>1)
                score += 500;
            if (cnt==1)
                score += 100;
        }

        function checkOverlap(figure) {
            var i, j;
            for (i = 0; i < 3; ++i)
                for (j = 0; j < 3; ++j) {
                    if (figure.data[i][j] != 0 && gameBoard[figure.i + i][figure.j + j] != 0)
                        return true;
                }
            return false;
        }

        function tryMove(figure, di, dj) {
            var movedFigure = new Figure();
            copyFigure(movedFigure, figure);
            movedFigure.i += di;
            movedFigure.j += dj;
            if (checkOverlap(movedFigure) == false) {
                //moveSound.play();
                figure.i = movedFigure.i;
                figure.j = movedFigure.j;
                return true;
            }
            return false;
        }

        function tryTurn(figure) {
            if (figure.code == FIGURE_CODE_CUBE)
                return false;
            var turnedFigure = new Figure();
            copyFigure(turnedFigure, figure);
            var i, j;
            for (i = 0; i < 3; ++i)
                for (j = 0; j < 3; ++j)
                    turnedFigure.data[i][j] = figure.data[2 - j][i];
            if (checkOverlap(turnedFigure) == false) {
                for (i = 0; i < 3; ++i)
                    for (j = 0; j < 3; ++j)
                        figure.data[i][j] = turnedFigure.data[i][j];
                return true;
            }
            return false;
        }

        function drawBoard() {
            drawContext.fillStyle = COLOR_GRAY;
            drawContext.fillRect(gameBoardPosX, 0, cellWidth * M - 1, cellHeight * 2);

            var i, j;
            for (i = 0; i < N; ++i) {
                for (j = 0; j < M; ++j) {
                    drawContext.fillStyle = getColor(gameBoard[i][j]);
                    if (gameBoard[i][j] != 0)
                        drawContext.fillRect(
                            gameBoardPosX + j * cellHeight,
                            gameBoardPosY + i * cellWidth, cellWidth - 1, cellHeight - 1);
                    else
                        drawContext.fillRect(
                            gameBoardPosX + j * cellHeight,
                            gameBoardPosY + i * cellWidth, cellWidth, cellHeight);
                }
            }
        }

        var lastLoop = new Date;
        function drawInfo() {
            var info = "";
            if (showFps) {
                var thisLoop = new Date;
                var fps = 1000 / (thisLoop - lastLoop);
                lastLoop = thisLoop;
                info = fps.toFixed(1) + ' fps ';
            }
            info += ' Score: ' + score;
            drawContext.fillStyle = COLOR_BLACK;
            drawContext.fillText(info, gameBoardPosX, cellHeight);
        }

        function drawFigure(figure) {
            drawContext.fillStyle = getColor(figure.colorCode);
            var i, j;
            for (i = 0; i < 3; ++i) {
                for (j = 0; j < 3; ++j) {
                    if (figure.data[i][j] != 0)
                        drawContext.fillRect(
                            gameBoardPosX + (figure.j + j) * cellHeight,
                            gameBoardPosY + (figure.i + i) * cellWidth, cellWidth - 1, cellHeight - 1);
                }
            }
        }

        function draw() {
            switch (gameState) {
                case GAME_STATE_MENU:
                    {
                        drawBoard();
                        drawContext.fillStyle = COLOR_BLACK;
                        drawContext.textAlign = "center";
                        var str = "Press to start.";
                        drawContext.fillText(str, myCanvas.width / 2, myCanvas.height / 2);
                    } break;
                case GAME_STATE_PLAY:
                    {
                        drawContext.textAlign = "left";
                        drawBoard();
                        drawInfo();
                        drawFigure(currentFigure);
                    } break;
                case GAME_STATE_END:
                    {
                        drawContext.fillStyle = COLOR_BLACK;
                        drawContext.textAlign = "center";
                        var str = "You result: " + score;
                        drawContext.fillText(str, myCanvas.width / 2, myCanvas.height / 2);
                    } break;
            }
        }
        var KEY_UP = 38, KEY_DOWN = 40, KEY_LEFT = 37, KEY_RIGHT = 39, KEY_ENTER = 13;
        function keyDown() {
            switch (gameState) {
                case GAME_STATE_MENU:
                    {
                        gameState = GAME_STATE_PLAY;
                    } break;
                case GAME_STATE_PLAY:
                    {
                        switch (event.keyCode) {
                            case KEY_UP:
                                nextMove = MOVE_ROTATE;
                                break;
                            case KEY_DOWN:
                                nextMove = MOVE_DOWN;
                                break;
                            case KEY_LEFT:
                                nextMove = MOVE_LEFT;
                                break;
                            case KEY_RIGHT:
                                nextMove = MOVE_RIGHT;
                                break;
                        }
                    } break;
                case GAME_STATE_END:
                    {
                        initGame();
                        gameState = GAME_STATE_MENU;
                    } break;
            }
        }
        var MB_LEFT = 1;
        function mouseDown() {
            //if (event.button == MB_LEFT)
            nextMove = MOVE_ROTATE;
        }
    </script>
</body>
</html>
